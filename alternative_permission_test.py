import mysql.connector
import time
import os

# Database connection details from environment variables
DB_HOST = os.environ.get("DB_HOST", "127.0.0.1")
DB_PORT = int(os.environ.get("DB_PORT", 3306))
DB_USER = os.environ.get("DB_USER", "root")
DB_PASSWORD = os.environ.get("DB_PASSWORD", "123456")
DB_NAME = os.environ.get("DB_NAME", "finance")

def get_db_connection():
    """Establishes a connection to the MySQL database."""
    return mysql.connector.connect(
        host=DB_HOST,
        port=DB_PORT,
        user=DB_USER,
        password=DB_PASSWORD,
        database=DB_NAME
    )

def get_subordinate_ids(cursor, supervisor_id: int) -> list[int]:
    """1. Get a list of employee IDs managed by the supervisor."""
    query = """
        SELECT subordinate_id FROM user_hierarchy WHERE user_id = %s
    """
    cursor.execute(query, (supervisor_id,))
    return [item[0] for item in cursor.fetchall()]

def get_order_ids_for_users(cursor, user_ids: list[int]) -> list[int]:
    """2. Get a list of authorized order_ids from the orders table."""
    if not user_ids:
        return []
    # Using string formatting for the IN clause placeholder part is safe here
    # because user_ids is a list of integers generated by the previous step.
    placeholders = ','.join(['%s'] * len(user_ids))
    query = f"SELECT order_id FROM orders WHERE user_id IN ({placeholders})"
    cursor.execute(query, tuple(user_ids))
    return [item[0] for item in cursor.fetchall()]

def get_customer_ids_for_users(cursor, user_ids: list[int]) -> list[int]:
    """3. Get a list of authorized customer_ids from the customers table."""
    if not user_ids:
        return []
    # Using string formatting for the IN clause placeholder part is safe here
    # because user_ids is a list of integers generated by the previous step.
    placeholders = ','.join(['%s'] * len(user_ids))
    query = f"SELECT customer_id FROM customers WHERE admin_user_id IN ({placeholders})"
    cursor.execute(query, tuple(user_ids))
    return [item[0] for item in cursor.fetchall()]

def get_financial_funds_batch(cursor, handle_by_ids: list[int], order_ids: list[int], customer_ids: list[int], batch_size: int = 1000):
    """4. Use financial_funds's handle_by, order_id, customer_id to OR IN list of IDs with batch processing."""

    all_results = []

    # Calculate total batches needed
    max_ids = max(len(handle_by_ids), len(order_ids), len(customer_ids))
    total_batches = (max_ids + batch_size - 1) // batch_size if max_ids > 0 else 0

    print(f"Processing {total_batches} batches with batch_size={batch_size}")

    for batch_idx in range(total_batches):
        start_idx = batch_idx * batch_size
        end_idx = start_idx + batch_size

        # Get batch slices
        batch_handle_by = handle_by_ids[start_idx:end_idx] if start_idx < len(handle_by_ids) else []
        batch_order_ids = order_ids[start_idx:end_idx] if start_idx < len(order_ids) else []
        batch_customer_ids = customer_ids[start_idx:end_idx] if start_idx < len(customer_ids) else []

        conditions = []
        params = []

        if batch_handle_by:
            placeholders = ','.join(['%s'] * len(batch_handle_by))
            conditions.append(f"handle_by IN ({placeholders})")
            params.extend(batch_handle_by)

        if batch_order_ids:
            placeholders = ','.join(['%s'] * len(batch_order_ids))
            conditions.append(f"order_id IN ({placeholders})")
            params.extend(batch_order_ids)

        if batch_customer_ids:
            placeholders = ','.join(['%s'] * len(batch_customer_ids))
            conditions.append(f"customer_id IN ({placeholders})")
            params.extend(batch_customer_ids)

        if not conditions:
            continue

        query = f"""
            SELECT fund_id, handle_by, order_id, customer_id, amount
            FROM financial_funds
            WHERE {' OR '.join(conditions)}
        """

        cursor.execute(query, tuple(params))
        batch_results = cursor.fetchall()
        all_results.extend(batch_results)

        print(f"Batch {batch_idx + 1}/{total_batches}: Found {len(batch_results)} records")

    return all_results


def main():
    """Main function to run the permission test."""
    supervisor_id = 2  # Supervisor ID to test, from main.py

    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()

        print(f"Testing permission for supervisor_id: {supervisor_id}")

        total_start_time = time.time()

        # Step 1
        start_time = time.time()
        subordinate_ids = get_subordinate_ids(cursor, supervisor_id)
        # The supervisor should also be included in the list of people with access
        if supervisor_id not in subordinate_ids:
            subordinate_ids.append(supervisor_id)
        print(f"Step 1: Found {len(subordinate_ids)} subordinate IDs in {time.time() - start_time:.4f}s")

        # Step 2
        start_time = time.time()
        order_ids = get_order_ids_for_users(cursor, subordinate_ids)
        print(f"Step 2: Found {len(order_ids)} order IDs in {time.time() - start_time:.4f}s")

        # Step 3
        start_time = time.time()
        customer_ids = get_customer_ids_for_users(cursor, subordinate_ids)
        print(f"Step 3: Found {len(customer_ids)} customer IDs in {time.time() - start_time:.4f}s")

        # Step 4
        start_time = time.time()
        funds = get_financial_funds_batch(cursor, subordinate_ids, order_ids, customer_ids, batch_size=1000)
        print(f"Step 4: Found {len(funds)} financial funds in {time.time() - start_time:.4f}s")

        total_time = time.time() - total_start_time
        print(f"\nTotal execution time: {total_time:.4f}s")

        print(f"\nFound {len(funds)} accessible financial funds for supervisor {supervisor_id}.")

        cursor.close()
    except mysql.connector.Error as err:
        print(f"Database error: {err}")
    finally:
        if conn and conn.is_connected():
            conn.close()

if __name__ == "__main__":
    main()
