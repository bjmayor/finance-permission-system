# Finance Permission System 性能测试总结

## 1. 测试环境与设置

### 1.1 测试环境
- **数据库**: MySQL 8.0
- **硬件环境**: 16GB RAM, 8核处理器
- **数据规模**: 每个表约1,000,000条记录
- **测试工具**: 自定义Python脚本

### 1.2 数据表结构
- **users**: 用户表 (1,000,004条记录)
- **orders**: 订单表 (1,000,003条记录)
- **customers**: 客户表 (1,000,003条记录)
- **financial_funds**: 财务资金表 (1,000,003条记录)
- **user_hierarchy**: 用户层级关系表 (19,527条记录)

### 1.3 用户层级
- 主管人数: 约200位
- 最大下属数: 1,005 (用户ID=999)
- 平均下属数: 8-12人

## 2. 基础查询性能

### 2.1 基本分页查询

| 查询类型 | 总记录数 | 获取总数时间 | 获取数据时间 | 总执行时间 |
|---------|---------|-------------|-------------|-----------|
| 无过滤条件 | 1,000,003 | 84ms | 3ms | 87ms |
| 按金额过滤 | 199,844 | 137ms | 1ms | 138ms |

### 2.2 多表关联查询

| 查询类型 | 总记录数 | 获取总数时间 | 获取数据时间 | 总执行时间 |
|---------|---------|-------------|-------------|-----------|
| 客户订单关联 | 998,238 | 432ms | 18ms | 450ms |
| 复杂财务报表 | 1,000,003 | 1,837ms | 41ms | 1,878ms |
| 优化后复杂报表 | 10,000 | 19ms | 38ms | 57ms |

## 3. 主管权限查询性能

### 3.1 不同规模主管查询对比

| 主管ID | 下属数量 | 获取下属时间 | 获取总数时间 | 获取数据时间 | 总执行时间 |
|--------|----------|-------------|-------------|-------------|-----------|
| 2 | 10 | 0.64ms | 0.45ms | 0.77ms | 1.86ms |
| 21 | 12 | 0.51ms | 0.38ms | 0.71ms | 1.61ms |
| 999 | 1005 | 5.72ms | 4.63ms | 8.54ms | 18.88ms |

### 3.2 排序对性能的影响

| 主管ID | 排序字段 | 排序方向 | 总执行时间 | 性能变化 |
|--------|---------|---------|-----------|---------|
| 2 | fund_id | ASC | 1.86ms | 基准 |
| 2 | amount | DESC | 1.85ms | -0.5% |
| 999 | fund_id | ASC | 18.88ms | 基准 |
| 999 | amount | DESC | 20.36ms | +7.8% |

### 3.3 分页对性能的影响

| 主管ID | 页码 | 每页记录数 | 总执行时间 | 性能变化 |
|--------|------|-----------|-----------|---------|
| 999 | 1 | 20 | 18.88ms | 基准 |
| 999 | 10 | 20 | 17.53ms | -7.1% |
| 999 | 50 | 20 | 18.12ms | -4.0% |

## 4. 递归CTE查询性能

### 4.1 递归CTE与非递归查询对比

| 用户ID | 下属数 | 方法 | 总记录数 | 获取总数时间 | 获取数据时间 | 总执行时间 |
|--------|--------|-----|---------|-------------|-------------|-----------|
| 2 | 10 | 递归CTE | 621,477 | 3,678ms | 3,790ms | 7,468ms |
| 2 | 10 | 非递归优化 | 59 | 478ms | 494ms | 974ms |
| 21 | 12 | 递归CTE | 261,590 | 1,978ms | 2,004ms | 3,981ms |
| 21 | 12 | 非递归优化 | 44 | 462ms | 482ms | 945ms |
| 999 | 1005 | 递归CTE | 2,629 | 659ms | 677ms | 1,336ms |
| 999 | 1005 | 非递归优化 | 2,933 | 548ms | 555ms | 1,110ms |

### 4.2 递归CTE查询执行计划分析

递归CTE的执行计划包含12个步骤:
1. 主查询扫描整个financial_funds表 (type: ALL)
2. 主查询通过主键关联users表 (type: eq_ref)
3. 第一个子查询通过子查询物化表过滤 (type: ALL)
4. 子查询通过idx_customers_admin_user_id索引访问customers表 (type: ref)
5. 递归CTE物化为derived3临时表 (type: ALL)
6. 第二个子查询通过物化表过滤 (type: ALL)
7. 子查询通过idx_orders_user_id索引访问orders表 (type: ref)
8. 递归CTE物化为另一个临时表 (type: ALL)
9. 递归CTE作为子查询使用 (type: ALL)
10. users表通过主键常量查找起始用户 (type: const)
11. 递归CTE基表访问 (type: ALL, Extra: Recursive)
12. 递归步骤通过idx_users_parent_id索引访问users表 (type: ref)

### 4.3 非递归优化查询执行计划分析

非递归优化查询的执行计划包含4个步骤:
1. 主查询扫描整个financial_funds表 (type: ALL)
2. 主查询通过主键关联users表 (type: eq_ref)
3. 子查询通过索引范围扫描customers表 (type: range)
4. 子查询通过索引范围扫描orders表 (type: range)

## 5. 性能瓶颈分析

### 5.1 主要瓶颈

1. **COUNT(*) 查询**:
   - 在百万级数据上执行COUNT(*)是最大瓶颈
   - 无过滤条件时需要80-1800ms不等
   - 占总查询时间的40-60%

2. **大型IN子句处理**:
   - 主管有大量下属时(1000+)，IN子句处理需要5-6ms
   - 多个表上执行相同IN子句会重复消耗资源

3. **复杂JOIN操作**:
   - 多表JOIN在无有效索引时性能极差
   - 3表以上JOIN查询时间增长显著

4. **递归CTE开销**:
   - 递归CTE实现的层级查询比预计算关系慢7-8倍
   - 递归深度越大，性能影响越明显

### 5.2 索引使用情况

| 查询类型 | 主要索引 | 索引类型 | 评估行数 | 备注 |
|---------|---------|---------|---------|------|
| 主管下属查询 | idx_hierarchy_user_id | ref | 10-1005 | 良好 |
| 按handle_by过滤 | idx_funds_handle_by | range | 1-1006 | 良好 |
| 递归CTE查询 | PRIMARY, idx_users_parent_id | const, ref | 1, 103 | 良好 |
| 财务总表扫描 | 无 | ALL | 997,545 | 极差 |
| 多表复杂查询 | 多个 | range, ref | 变化 | 一般 |

## 6. 优化建议

### 6.1 查询优化

1. **总数查询优化**:
   - 使用近似计数方法: `EXPLAIN SELECT COUNT(*)`
   - 异步计算和缓存总数
   - 实现无限滚动代替传统分页

2. **权限模型优化**:
   - 使用非递归方法代替递归CTE
   - 预计算和缓存权限范围
   - 限制权限查询的最大深度

3. **数据查询优化**:
   - 分离ID查询和数据查询
   - 使用临时表存储中间结果
   - 应用查询重写技术

### 6.2 索引优化

1. **复合索引推荐**:
   - `CREATE INDEX idx_funds_amount_handle ON financial_funds (amount, handle_by)`
   - `CREATE INDEX idx_funds_handle_amount ON financial_funds (handle_by, amount)`
   - `CREATE INDEX idx_hierarchy_user_depth ON user_hierarchy (user_id, depth)`

2. **覆盖索引应用**:
   - 确保索引包含查询所需的所有字段
   - 减少回表操作

3. **现有索引优化**:
   - 调整现有索引顺序以匹配查询模式
   - 移除未使用的索引

### 6.3 架构优化

1. **数据分区**:
   - 按部门或地区分区
   - 减少大表扫描范围

2. **权限缓存**:
   - 实现权限范围的内存缓存
   - 采用定时失效策略

3. **读写分离**:
   - 复杂查询路由到读副本
   - 减轻主库负担

## 7. 结论

1. **性能总体评估**:
   - 系统在百万级数据量下表现良好
   - 典型查询响应时间在10-100ms范围内
   - 极端复杂查询(递归CTE)响应时间在1-8秒范围

2. **权限模型效率**:
   - 非递归权限模型性能最佳，应作为首选
   - 大型组织层级(1000+)下性能仍可接受(<20ms)
   - 预计算关系表是必要的性能优化手段

3. **扩展性评估**:
   - 系统可支持千万级数据
   - 查询时间与数据量近似线性增长
   - 主要瓶颈可通过优化建议缓解

4. **最终推荐**:
   - 采用非递归权限模型
   - 实施上述索引优化
   - 实现分页数据和总数的异步加载
   - 监控实际查询模式并持续优化